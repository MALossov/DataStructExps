# 一、基本题

## Ex3-1:【链栈】

1. 链栈结点类型定义为：

```c
typedef struct node
{
int  data;
struct node *next;
}node_type;
```

2. 编写进栈函数push
3. 编写出栈函数pop
4. 编写main函数，
   1. 首先建立一空链栈；
   2. 调用进栈函数，将从键盘输入的数据元素逐个进栈，输入0结束；显示进栈后的数据元素；
   3. 调用两次出栈函数，显示出栈后的数据元素。

## Ex3-2:【循环队列】

1. 循环队列类型定义为：

```c
#define N 20
typedef struct
{ int data[N];
int front, rear;
}queue_type;
```

2. 编写循环队列出队函数dequeue
3. 编写循环队列入队函数enqueue
4. 编写函数：void aa(queue_type *q)；

> 其功能为，调用出队函数把队列q中的元素一一出队，如果是负数直接抛弃；如果是正数，则调用入队函数，插入到q的队尾。

5. 编写main函数，首先建立一个队列，
   1. 其中的数据元素为：`{2, 3, -4, 6, -5, 8, -9, 7, -10, 20}`；
   2. 然后调用aa函数，并将aa函数调用前后队列的数据元素分别输出到屏幕上。

# 二、扩展题

## Ex3-3:【栈】

1. 两个栈共用一个数组空间，它们的栈底分别在数组两端，栈顶相向而行。编写入栈和出栈函数，实现两个栈元素分别的（但共用）入栈和出栈。
2. main中函数完成以下测试：
   1. 能否在共用空间上实现两个独立的栈：即能否向两个栈分别输入元素；能否分别从两个栈取出元素，每个栈取出的元素的顺序符合各自栈的特点
   2. 能否在共用空间用满时，及时制止新的入栈行为。

## Ex3-4:【队列】

1. 实现一种扩展的循环队列，
   1. 使得全部的数组空间都能使用，基本思路是当传统循环队列放满时：即`(rear+1)%MAXNUM ==front`为真时，可以再入队一个元素，
   2. 接着`rear = (rear+1)%MAXNUM`后就会与front相等，此时将另外一个变量flag设置为1，表示此时的rear==front不是为空，而是满。
   3. 否则flag为0时，如果出现rear==front，则表示队列为空。
2. main()函数实现以下测试：
   1. 能否实现全部“装满”，即装入元素个数为MAXNUM
   2. 能否按照循环队列那样绕着存放空间循环存放。
   3. 能否在装满后，拒绝再装。
   4. 能否在装满后，不会变成“空”的——即可以还可正常出队。
   5. 能否在全部出空后，不会变成“满”的——即可还可正常入队。

# 三、选做题

## Ex3-5:

利用栈实现算术四则运算，即录入一个包含加减乘除运算的多项式，计算出结果。暂不考虑“括号”。
本题算法难点在如何利用栈，驱动运算过程。
> 本题程序难点在从输入的一个形如“3+4×16-4/3”的字符串中依次提取出各个数字和运算符。

## Ex3-6

计算并输出二项展开式（a+b）n的各项系数，即求一个杨辉三角形的最下面一层所有元素。
本题算法难点在利用杨辉三角形计算原理，不断利用队列在上一层元素的基础上，求出下一层元素。